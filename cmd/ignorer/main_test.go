package main

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
	
	"github.com/ignorer/ignorer/internal/core"
)

func TestMainCommand(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "ignorer_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Change to temp directory
	oldDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get current dir: %v", err)
	}
	defer func() {
		if err := os.Chdir(oldDir); err != nil {
			t.Errorf("Failed to restore original directory: %v", err)
		}
	}()

	err = os.Chdir(tempDir)
	if err != nil {
		t.Fatalf("Failed to change to temp dir: %v", err)
	}

	tests := []struct {
		name        string
		args        []string
		expectError bool
		expectFile  bool
		fileContent []string
	}{
		{
			name:        "Generate Go gitignore",
			args:        []string{"go"},
			expectError: false,
			expectFile:  true,
			fileContent: []string{"# Generated by ignorer CLI", "# === GO ===", "*.exe"},
		},
		{
			name:        "Generate multiple templates",
			args:        []string{"go", "docker"},
			expectError: false,
			expectFile:  true,
			fileContent: []string{"# === GO ===", "# === DOCKER ==="},
		},
		{
			name:        "Invalid template",
			args:        []string{"nonexistent"},
			expectError: true,
			expectFile:  false,
			fileContent: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Remove any existing .gitignore
			os.Remove(".gitignore")

			// Capture output
			var buf bytes.Buffer

			// Simulate command line args
			os.Args = append([]string{"ignorer"}, tt.args...)

			// Reset root command
			rootCmd.SetOut(&buf)
			rootCmd.SetErr(&buf)

			err := rootCmd.Execute()

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if tt.expectFile {
				// Check if .gitignore file was created
				gitignorePath := filepath.Join(".", ".gitignore")
				if _, err := os.Stat(gitignorePath); os.IsNotExist(err) {
					t.Errorf("Expected .gitignore file to be created")
					return
				}

				// Read and verify content
				content, err := os.ReadFile(gitignorePath)
				if err != nil {
					t.Errorf("Failed to read .gitignore: %v", err)
					return
				}

				contentStr := string(content)
				for _, expected := range tt.fileContent {
					if !strings.Contains(contentStr, expected) {
						t.Errorf("Expected content '%s' not found in .gitignore", expected)
					}
				}
			}
		})
	}
}

func TestListCommand(t *testing.T) {
	// Test list command execution
	err := listTemplates(listCmd, []string{})
	if err != nil {
		t.Fatalf("List command failed: %v", err)
	}
	
	// The function executed successfully, which means it can load templates
	// and display them. Since it prints directly to stdout, we verify the 
	// core functionality works by checking the template manager directly.
	
	tm := core.NewTemplateManager()
	err = tm.LoadTemplates()
	if err != nil {
		t.Fatalf("Failed to load templates: %v", err)
	}
	
	templates := tm.ListTemplates()
	
	// Verify common templates exist
	commonTemplates := []string{"go", "swift", "python", "node", "docker"}
	templateMap := make(map[string]bool)
	for _, template := range templates {
		templateMap[template] = true
	}
	
	for _, expected := range commonTemplates {
		if !templateMap[expected] {
			t.Errorf("Expected template '%s' not found", expected)
		}
	}
}
