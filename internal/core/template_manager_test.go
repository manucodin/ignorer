package core

import (
	"strings"
	"testing"
)

func TestNewTemplateManager(t *testing.T) {
	tm := NewTemplateManager()

	if tm == nil {
		t.Fatal("NewTemplateManager() returned nil")
	}

	if tm.templates == nil {
		t.Fatal("templates map is nil")
	}
}

func TestLoadTemplates(t *testing.T) {
	tm := NewTemplateManager()

	err := tm.LoadTemplates()
	if err != nil {
		t.Fatalf("LoadTemplates() failed: %v", err)
	}

	// Check that some expected templates are loaded
	expectedTemplates := []string{"swift", "go", "python", "node", "java", "rust", "react", "docker", "xcode", "macos"}

	for _, expected := range expectedTemplates {
		if !tm.HasTemplate(expected) {
			t.Errorf("Expected template '%s' not found", expected)
		}
	}
}

func TestListTemplates(t *testing.T) {
	tm := NewTemplateManager()
	err := tm.LoadTemplates()
	if err != nil {
		t.Fatalf("LoadTemplates() failed: %v", err)
	}

	templates := tm.ListTemplates()

	if len(templates) == 0 {
		t.Fatal("ListTemplates() returned empty list")
	}

	// Check that templates are sorted
	for i := 1; i < len(templates); i++ {
		if templates[i-1] > templates[i] {
			t.Errorf("Templates are not sorted: %s > %s", templates[i-1], templates[i])
		}
	}

	// Check that expected templates exist
	templateMap := make(map[string]bool)
	for _, template := range templates {
		templateMap[template] = true
	}

	expectedTemplates := []string{"swift", "go", "python", "node"}
	for _, expected := range expectedTemplates {
		if !templateMap[expected] {
			t.Errorf("Expected template '%s' not found in list", expected)
		}
	}
}

func TestGenerateGitignore(t *testing.T) {
	tm := NewTemplateManager()
	err := tm.LoadTemplates()
	if err != nil {
		t.Fatalf("LoadTemplates() failed: %v", err)
	}

	tests := []struct {
		name          string
		templates     []string
		expectError   bool
		expectContent []string
	}{
		{
			name:          "Single template",
			templates:     []string{"go"},
			expectError:   false,
			expectContent: []string{"# Generated by ignorer CLI", "# === GO ===", "*.exe"},
		},
		{
			name:          "Multiple templates",
			templates:     []string{"go", "docker"},
			expectError:   false,
			expectContent: []string{"# Generated by ignorer CLI", "# === GO ===", "# === DOCKER ==="},
		},
		{
			name:          "Non-existent template",
			templates:     []string{"nonexistent"},
			expectError:   true,
			expectContent: nil,
		},
		{
			name:          "Empty templates",
			templates:     []string{},
			expectError:   true,
			expectContent: nil,
		},
		{
			name:          "Mix of valid and invalid",
			templates:     []string{"go", "nonexistent"},
			expectError:   true,
			expectContent: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			content, err := tm.GenerateGitignore(tt.templates)

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			for _, expected := range tt.expectContent {
				if !strings.Contains(content, expected) {
					t.Errorf("Expected content '%s' not found in generated gitignore", expected)
				}
			}
		})
	}
}

func TestHasTemplate(t *testing.T) {
	tm := NewTemplateManager()
	err := tm.LoadTemplates()
	if err != nil {
		t.Fatalf("LoadTemplates() failed: %v", err)
	}

	tests := []struct {
		name     string
		template string
		expected bool
	}{
		{"Existing template lowercase", "go", true},
		{"Existing template uppercase", "GO", true},
		{"Existing template mixed case", "Go", true},
		{"Non-existing template", "nonexistent", false},
		{"Empty template", "", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tm.HasTemplate(tt.template)
			if result != tt.expected {
				t.Errorf("HasTemplate(%s) = %v, expected %v", tt.template, result, tt.expected)
			}
		})
	}
}

func TestCleanTemplateContent(t *testing.T) {
	tm := NewTemplateManager()

	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Content with leading and trailing empty lines",
			input:    "\n\n# Comment\n*.txt\n\n\n",
			expected: "# Comment\n*.txt",
		},
		{
			name:     "Content without leading/trailing empty lines",
			input:    "# Comment\n*.txt",
			expected: "# Comment\n*.txt",
		},
		{
			name:     "Only empty lines",
			input:    "\n\n\n",
			expected: "",
		},
		{
			name:     "Empty content",
			input:    "",
			expected: "",
		},
		{
			name:     "Single line",
			input:    "*.txt",
			expected: "*.txt",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tm.cleanTemplateContent(tt.input)
			if result != tt.expected {
				t.Errorf("cleanTemplateContent() = %q, expected %q", result, tt.expected)
			}
		})
	}
}

func TestGenerateGitignoreHeader(t *testing.T) {
	tm := NewTemplateManager()
	err := tm.LoadTemplates()
	if err != nil {
		t.Fatalf("LoadTemplates() failed: %v", err)
	}

	content, err := tm.GenerateGitignore([]string{"go"})
	if err != nil {
		t.Fatalf("GenerateGitignore() failed: %v", err)
	}

	expectedHeaders := []string{
		"# Generated by ignorer CLI",
		"# Templates: go",
		"# https://github.com/manucodin/ignorer",
	}

	for _, header := range expectedHeaders {
		if !strings.Contains(content, header) {
			t.Errorf("Expected header '%s' not found in generated content", header)
		}
	}
}
