package core

import (
	"embed"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
)

//go:embed templates/*.gitignore
var templatesFS embed.FS

// TemplateManager handles loading and combining gitignore templates
type TemplateManager struct {
	templates map[string]string
}

// NewTemplateManager creates a new instance of TemplateManager
func NewTemplateManager() *TemplateManager {
	return &TemplateManager{
		templates: make(map[string]string),
	}
}

// LoadTemplates loads all available gitignore templates from embedded files
func (tm *TemplateManager) LoadTemplates() error {
	entries, err := templatesFS.ReadDir("templates")
	if err != nil {
		return fmt.Errorf("failed to read templates directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".gitignore") {
			continue
		}

		// Extract template name from filename (remove .gitignore extension)
		templateName := strings.TrimSuffix(entry.Name(), ".gitignore")

		// Read template content
		content, err := templatesFS.ReadFile(filepath.Join("templates", entry.Name()))
		if err != nil {
			return fmt.Errorf("failed to read template %s: %w", templateName, err)
		}

		tm.templates[templateName] = string(content)
	}

	return nil
}

// ListTemplates returns a sorted list of available template names
func (tm *TemplateManager) ListTemplates() []string {
	templates := make([]string, 0, len(tm.templates))
	for name := range tm.templates {
		templates = append(templates, name)
	}
	sort.Strings(templates)
	return templates
}

// GenerateGitignore combines multiple templates into a single gitignore content
func (tm *TemplateManager) GenerateGitignore(templateNames []string) (string, error) {
	if len(templateNames) == 0 {
		return "", fmt.Errorf("no templates specified")
	}

	var parts []string
	var notFound []string

	// Add header comment
	parts = append(parts, "# Generated by ignorer CLI")
	parts = append(parts, fmt.Sprintf("# Templates: %s", strings.Join(templateNames, ", ")))
	parts = append(parts, "# https://github.com/manucodin/ignorer")
	parts = append(parts, "")

	// Process each requested template
	for _, templateName := range templateNames {
		templateName = strings.ToLower(strings.TrimSpace(templateName))

		content, exists := tm.templates[templateName]
		if !exists {
			notFound = append(notFound, templateName)
			continue
		}

		// Add section header
		parts = append(parts, fmt.Sprintf("# === %s ===", strings.ToUpper(templateName)))

		// Clean and add template content
		cleanContent := tm.cleanTemplateContent(content)
		if cleanContent != "" {
			parts = append(parts, cleanContent)
		}
		parts = append(parts, "")
	}

	// Report any templates that weren't found
	if len(notFound) > 0 {
		availableTemplates := tm.ListTemplates()
		return "", fmt.Errorf("templates not found: %s\nAvailable templates: %s",
			strings.Join(notFound, ", "),
			strings.Join(availableTemplates, ", "))
	}

	if len(parts) <= 4 { // Only header, no actual content
		return "", fmt.Errorf("no valid templates found")
	}

	return strings.Join(parts, "\n"), nil
}

// cleanTemplateContent removes empty lines at the beginning and end of template content
func (tm *TemplateManager) cleanTemplateContent(content string) string {
	lines := strings.Split(content, "\n")

	// Remove empty lines from the beginning
	start := 0
	for start < len(lines) && strings.TrimSpace(lines[start]) == "" {
		start++
	}

	// Remove empty lines from the end
	end := len(lines) - 1
	for end >= 0 && strings.TrimSpace(lines[end]) == "" {
		end--
	}

	if start > end {
		return ""
	}

	return strings.Join(lines[start:end+1], "\n")
}

// HasTemplate checks if a template exists
func (tm *TemplateManager) HasTemplate(templateName string) bool {
	_, exists := tm.templates[strings.ToLower(templateName)]
	return exists
}
